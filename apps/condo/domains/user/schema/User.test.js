/**
 * Generated by `createschema user.User name:Text; password?:Password; isAdmin?:Checkbox; email?:Text; isEmailVerified?:Checkbox; phone?:Text; isPhoneVerified?:Checkbox; avatar?:File; meta:Json; importId:Text;`
 */
const gql = require('graphql-tag')

const { WRONG_EMAIL_ERROR } = require('@condo/domains/user/constants/errors')
const { getRandomString, makeLoggedInAdminClient, makeClient } = require('@core/keystone/test.utils')

const { User, UserAdmin, createTestUser, updateTestUser, makeClientWithNewRegisteredAndLoggedInUser, makeLoggedInClient, makeClientWithSupportUser } = require('@condo/domains/user/utils/testSchema')
const { createTestOrganization } = require('@condo/domains/organization/utils/testSchema')
const { expectToThrowAccessDeniedErrorToObjects,  expectToThrowAccessDeniedErrorToObj, expectToThrowAuthenticationErrorToObj, expectToThrowForbiddenError } = require('@condo/domains/common/utils/testSchema')
const { throwIfError } = require('@condo/domains/common/utils/codegeneration/generate.test.utils')
const { GET_MY_USERINFO, SIGNIN_MUTATION } = require('@condo/domains/user/gql')
const { DEFAULT_TEST_USER_IDENTITY, DEFAULT_TEST_USER_SECRET } = require('@core/keystone/test.utils')
const { WRONG_PASSWORD_ERROR, EMPTY_PASSWORD_ERROR } = require('@condo/domains/user/constants/errors')
const { registerNewOrganization } = require('@condo/domains/organization/utils/testSchema/Organization')
const { generateGqlQueries } = require('@condo/domains/common/utils/codegeneration/generate.gql')

describe('SIGNIN', () => {
    test('anonymous: SIGNIN_MUTATION', async () => {
        const client = await makeClient()
        const { data, errors } = await client.mutate(SIGNIN_MUTATION, {
            'identity': DEFAULT_TEST_USER_IDENTITY,
            'secret': DEFAULT_TEST_USER_SECRET,
        })
        expect(data.auth.user.id).toMatch(/[a-zA-Z0-9-_]+/)
        expect(errors).toEqual(undefined)
    })

    test('anonymous: GET_MY_USERINFO', async () => {
        const client = await makeClient()
        const { data, errors } = await client.query(GET_MY_USERINFO)
        expect(errors).toEqual(undefined)
        expect(data).toEqual({ 'user': null })
    })

    test('user: GET_MY_USERINFO', async () => {
        const client = await makeLoggedInClient()
        const { data, errors } = await client.query(GET_MY_USERINFO)
        expect(errors).toEqual(undefined)
        expect(data.user).toEqual(expect.objectContaining({ id: client.user.id }))
    })

    test('anonymous: SIGNIN_MUTATION by wrong password', async () => {
        const client = await makeClient()
        const { data, errors } = await client.mutate(SIGNIN_MUTATION, {
            'identity': DEFAULT_TEST_USER_IDENTITY,
            'secret': 'wrong password',
        })
        expect(data).toEqual({ 'auth': null })
        expect(JSON.stringify(errors)).toMatch((WRONG_PASSWORD_ERROR))
    })

    test('anonymous: SIGNIN_MUTATION by wrong email', async () => {
        const client = await makeClient()
        const { data, errors } = await client.mutate(SIGNIN_MUTATION, {
            'identity': 'some3571592131usermail@example.com',
            'secret': 'wrong password',
        })
        expect(data).toEqual({ 'auth': null })
        expect(JSON.stringify(errors)).toMatch(WRONG_EMAIL_ERROR)
    })

    test('check auth by empty password', async () => {
        const admin = await makeLoggedInAdminClient()
        const [, userAttrs] = await createTestUser(admin, { password: '' })
        const checkAuthByEmptyPassword = async () => {
            await makeLoggedInClient({ email: userAttrs.email, password: '' })
        }
        await expect(checkAuthByEmptyPassword).rejects.toThrow(EMPTY_PASSWORD_ERROR)
    })
})

describe('User', () => {
    test('user: create User', async () => {
        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await createTestUser(client)
        })
    })

    test('anonymous: create User', async () => {
        const client = await makeClient()
        await expectToThrowAuthenticationErrorToObj(async () => {
            await createTestUser(client)
        })
    })

    test('user: read User', async () => {
        const admin = await makeLoggedInAdminClient()
        await createTestUser(admin)

        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const { data } = await UserAdmin.getAll(client, {}, { raw: true, sortBy: ['updatedAt_DESC'] })
        expect(data.objs).toEqual(
            expect.arrayContaining([
                expect.objectContaining({ id: client.user.id, email: client.userAttrs.email }),
                expect.objectContaining({ email: null }),
            ]),
        )
        expect(data.objs.length >= 1).toBeTruthy()
    })

    test('anonymous: read User', async () => {
        const client = await makeClient()
        await expectToThrowAccessDeniedErrorToObjects(async () => {
            await User.getAll(client)
        })
    })

    test('user: update User', async () => {
        const admin = await makeLoggedInAdminClient()
        const [objCreated] = await createTestUser(admin)

        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        const payload = {}
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await updateTestUser(client, objCreated.id, payload)
        })
    })

    test('anonymous: update User', async () => {
        const admin = await makeLoggedInAdminClient()
        const [objCreated] = await createTestUser(admin)

        const client = await makeClient()
        const payload = {}
        await expectToThrowAuthenticationErrorToObj(async () => {
            await updateTestUser(client, objCreated.id, payload)
        })
    })

    test('user: delete User', async () => {
        const admin = await makeLoggedInAdminClient()
        const [objCreated] = await createTestUser(admin)

        const client = await makeClientWithNewRegisteredAndLoggedInUser()
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await User.delete(client, objCreated.id)
        })
    })

    test('anonymous: delete User', async () => {
        const admin = await makeLoggedInAdminClient()
        const [objCreated] = await createTestUser(admin)

        const client = await makeClient()
        await expectToThrowAccessDeniedErrorToObj(async () => {
            await User.delete(client, objCreated.id)
        })
    })

    test('anonymous: count', async () => {
        const client = await makeClient()
        const { data, errors } = await User.count(client, {}, { raw: true })
        expect(data).toEqual({ meta: { count: null } })
        expect(errors[0]).toMatchObject({
            'data': { 'target': '_allUsersMeta', 'type': 'query' },
            'message': 'You do not have access to this resource',
            'name': 'AccessDeniedError',
            'path': ['meta', 'count'],
        })
    })

    test('user: count', async () => {
        const admin = await makeLoggedInAdminClient()
        const [, userAttrs] = await createTestUser(admin)
        const client = await makeLoggedInClient(userAttrs)
        const count = await User.count(client)
        expect(count).toBeGreaterThanOrEqual(2)
    })
})

describe('User utils', () => {
    test('createUser()', async () => {
        const admin = await makeLoggedInAdminClient()
        const [user, userAttrs] = await createTestUser(admin)
        expect(user.id).toMatch(/^[A-Za-z0-9-]+$/g)
        expect(userAttrs.email).toBeTruthy()
        expect(userAttrs.password).toBeTruthy()
    })

})

describe('User fields', () => {
    test('Convert email to lower case', async () => {
        const admin = await makeLoggedInAdminClient()
        const email = 'XXX' + getRandomString() + '@example.com'
        const [user, userAttrs] = await createTestUser(admin, { email })

        const objs = await UserAdmin.getAll(admin, { id: user.id })
        expect(objs[0]).toEqual(expect.objectContaining({ email: email.toLowerCase(), id: user.id }))

        const client2 = await makeLoggedInClient({ password: userAttrs.password, email: email.toLowerCase() })
        expect(client2.user.id).toEqual(user.id)

        // TODO(pahaz): fix in a future (it's no OK if you can't logged in by upper case email)
        const checkAuthByUpperCaseEmail = async () => {
            await makeLoggedInClient(userAttrs)
        }
        await expect(checkAuthByUpperCaseEmail).rejects.toThrow(WRONG_EMAIL_ERROR)
    })
})
describe('Service Custom permissions', () => {
    describe('Accesses', () => {
        const GET_USERS_PERMISSIONS_QUERY = generateGqlQueries('User', '{ permissions }').GET_ALL_OBJS_QUERY

        test('Admin can operate with permissions field', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
    
            await updateTestUser(adminClient, userClient.user.id, {
                permissions: {
                    canReadOrganizations: true,
                },
            })
            const permissionsReadByAdmin = await adminClient.query(GET_USERS_PERMISSIONS_QUERY, {
                where: {
                    id: userClient.user.id,
                },
            }).then(r => r.data.objs[0].permissions)

            expect(permissionsReadByAdmin).toBeDefined()
            expect(permissionsReadByAdmin).toMatchObject({
                canReadOrganizations: true,
            })
        })
        test('Support can operate with permissions field', async () => {
            const supportClient = await makeClientWithSupportUser()
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
    
            await updateTestUser(supportClient, userClient.user.id, {
                permissions: {
                    canReadOrganizations: true,
                },
            })
    
            const permissionsReadBySupport = await supportClient.query(GET_USERS_PERMISSIONS_QUERY, {
                where: {
                    id: userClient.user.id,
                },
            }).then(r => r.data.objs[0].permissions)

    
            expect(permissionsReadBySupport).toBeDefined()
            expect(permissionsReadBySupport).toMatchObject({
                canReadOrganizations: true,
            })
        })
        test('Common users cannot read permissions field', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const serviceUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
            const commonUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
    
            await updateTestUser(adminClient, serviceUserClient.user.id, {
                permissions: {
                    canReadOrganizations: true,
                },
            })
            
            const { data, errors } = await commonUserClient.query(GET_USERS_PERMISSIONS_QUERY, {
                where: {
                    id: serviceUserClient.user.id,
                },
            })
            expect(data).toMatchObject({
                objs: [{ permissions: null }],
            })
            expect(errors[0]).toMatchObject({
                'message': 'You do not have access to this resource',
                'name': 'AccessDeniedError',
                'path': ['objs', 0, 'permissions'],
            })
        })

        test('Service users cannot read own permissions field', async () => {
            const adminClient = await makeLoggedInAdminClient()
            const serviceUserClient = await makeClientWithNewRegisteredAndLoggedInUser()
    
            await updateTestUser(adminClient, serviceUserClient.user.id, {
                permissions: {
                    canReadOrganizations: true,
                },
            })
            
            await expectToThrowForbiddenError(async () => {
                const { data, errors } = await serviceUserClient.query(GET_USERS_PERMISSIONS_QUERY, {
                    where: {
                        id: serviceUserClient.user.id,
                    },
                })
                throwIfError(data, errors)
            }, ['objs'])
        })
    
        test('Users cannot update permissions field', async () => {
            const userClient = await makeClientWithNewRegisteredAndLoggedInUser()
            await expectToThrowAccessDeniedErrorToObj(async () => {
                await updateTestUser(userClient, userClient.user.id, {
                    permissions: {
                        canReadOrganizations: true,
                    },
                })
            })
        })
    })

    describe('List operations', () => {
        test('User with permissions can perform allowed list operations', async () => {
            const admin = await makeLoggedInAdminClient()
            await createTestOrganization(admin)

            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await updateTestUser(admin, client.user.id, {
                permissions: {
                    canReadOrganizations: true,
                },
            })

            const query = generateGqlQueries('Organization', '{ _label_ id meta }').GET_ALL_OBJS_QUERY
            const { data: { objs: organizationsSeenByAdmin } } = await admin.query(query)
            const { data: { objs: organizationsSeenByUser } }  = await client.query(query)
            expect(organizationsSeenByUser).toHaveLength(organizationsSeenByAdmin.length)
        })
        test('User with permissions can perform allowed nested list operations', async () => {
            const admin = await makeLoggedInAdminClient()
            await createTestOrganization(admin)
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await updateTestUser(admin, client.user.id, {
                permissions: {
                    canReadOrganizations: true,
                    canReadUsers: true,
                },
            })

            const query = generateGqlQueries('Organization', '{ createdBy { name } }').GET_ALL_OBJS_QUERY
            const { data: { objs: organizationsSeenByUser } }  = await client.query(query)
            expect(organizationsSeenByUser[0].createdBy.name).not.toBeUndefined()
        })
        test('User with permissions cannot perform inner access-frobidden nested list operations', async () => {
            const admin = await makeLoggedInAdminClient()
            await createTestOrganization(admin)

            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await updateTestUser(admin, client.user.id, {
                permissions: {
                    canReadOrganizations: true,
                    canReadUsers: true,
                },
            })

            const query = generateGqlQueries('Organization', '{ createdBy { phone } }').GET_ALL_OBJS_QUERY
            const { data, errors } = await client.query(query, {
                first: 1,
            })
            expect(data).toMatchObject({
                objs: [{ createdBy: { phone: null } }],
            })
            expect(errors[0]).toMatchObject({
                'message': 'You do not have access to this resource',
                'name': 'AccessDeniedError',
                'path': ['objs', 0, 'createdBy', 'phone'],
            })
        })
    
        test('User with permissions cannot perform forbidden list operations', async ()=> {
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            const admin = await makeLoggedInAdminClient()
            await updateTestUser(admin, client.user.id, {
                permissions: {
                    canReadOrganizations: false,
                },
            })
            const query = generateGqlQueries('Organization', '{ _label_ id meta }').GET_ALL_OBJS_QUERY
            await expectToThrowForbiddenError(async () => {
                const { data, errors } = await client.query(query)
                throwIfError(data, errors)
            }, ['objs'])
        })
    })

    describe('Service operations', () => {
        test('User with permission can perform allowed service operations', async () => {
            const admin = await makeLoggedInAdminClient()
            await createTestOrganization(admin)
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await updateTestUser(admin, client.user.id, {
                permissions: {
                    canRegisterNewOrganization: true,
                    canReadOrganizations: true,
                    canReadUsers: true,
                    canReadOrganizationLinks: true,
                },
            })
            await registerNewOrganization(client)
        })
        
        test('User with permissions cannot perform forbidden service operations', async ()=> {
            const admin = await makeLoggedInAdminClient()
            await createTestOrganization(admin)
            const client = await makeClientWithNewRegisteredAndLoggedInUser()
            await updateTestUser(admin, client.user.id, {
                permissions: {
                    canRegisterNewOrganization: false,
                },
            })
            const REGISTER_NEW_ORGANIZATION_MUTATION = gql`
                mutation registerNewOrganization($data: RegisterNewOrganizationInput!) {
                    obj: registerNewOrganization(data: $data) {name}
                }`
            await expectToThrowForbiddenError(async () => {
                const { data, errors } = await registerNewOrganization(client, {}, { raw: true }, REGISTER_NEW_ORGANIZATION_MUTATION)
                throwIfError(data, errors)
            }, ['obj'])
        })
    })  
})